/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/simplex-noise/dist/esm/simplex-noise.js":
/*!**************************************************************!*\
  !*** ./node_modules/simplex-noise/dist/esm/simplex-noise.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildPermutationTable: () => (/* binding */ buildPermutationTable),\n/* harmony export */   createNoise2D: () => (/* binding */ createNoise2D),\n/* harmony export */   createNoise3D: () => (/* binding */ createNoise3D),\n/* harmony export */   createNoise4D: () => (/* binding */ createNoise4D)\n/* harmony export */ });\n/*\n * A fast javascript implementation of simplex noise by Jonas Wagner\n\nBased on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.\nWhich is based on example code by Stefan Gustavson (stegu@itn.liu.se).\nWith Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\nBetter rank ordering method by Stefan Gustavson in 2012.\n\n Copyright (c) 2024 Jonas Wagner\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n */\n// these __PURE__ comments help uglifyjs with dead code removal\n//\nconst SQRT3 = /*#__PURE__*/ Math.sqrt(3.0);\nconst SQRT5 = /*#__PURE__*/ Math.sqrt(5.0);\nconst F2 = 0.5 * (SQRT3 - 1.0);\nconst G2 = (3.0 - SQRT3) / 6.0;\nconst F3 = 1.0 / 3.0;\nconst G3 = 1.0 / 6.0;\nconst F4 = (SQRT5 - 1.0) / 4.0;\nconst G4 = (5.0 - SQRT5) / 20.0;\n// I'm really not sure why this | 0 (basically a coercion to int)\n// is making this faster but I get ~5 million ops/sec more on the\n// benchmarks across the board or a ~10% speedup.\nconst fastFloor = (x) => Math.floor(x) | 0;\nconst grad2 = /*#__PURE__*/ new Float64Array([1, 1,\n    -1, 1,\n    1, -1,\n    -1, -1,\n    1, 0,\n    -1, 0,\n    1, 0,\n    -1, 0,\n    0, 1,\n    0, -1,\n    0, 1,\n    0, -1]);\n// double seems to be faster than single or int's\n// probably because most operations are in double precision\nconst grad3 = /*#__PURE__*/ new Float64Array([1, 1, 0,\n    -1, 1, 0,\n    1, -1, 0,\n    -1, -1, 0,\n    1, 0, 1,\n    -1, 0, 1,\n    1, 0, -1,\n    -1, 0, -1,\n    0, 1, 1,\n    0, -1, 1,\n    0, 1, -1,\n    0, -1, -1]);\n// double is a bit quicker here as well\nconst grad4 = /*#__PURE__*/ new Float64Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,\n    0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,\n    1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,\n    -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,\n    1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,\n    -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,\n    1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,\n    -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]);\n/**\n * Creates a 2D noise function\n * @param random the random function that will be used to build the permutation table\n * @returns {NoiseFunction2D}\n */\nfunction createNoise2D(random = Math.random) {\n    const perm = buildPermutationTable(random);\n    // precalculating this yields a little ~3% performance improvement.\n    const permGrad2x = new Float64Array(perm).map(v => grad2[(v % 12) * 2]);\n    const permGrad2y = new Float64Array(perm).map(v => grad2[(v % 12) * 2 + 1]);\n    return function noise2D(x, y) {\n        // if(!isFinite(x) || !isFinite(y)) return 0;\n        let n0 = 0; // Noise contributions from the three corners\n        let n1 = 0;\n        let n2 = 0;\n        // Skew the input space to determine which simplex cell we're in\n        const s = (x + y) * F2; // Hairy factor for 2D\n        const i = fastFloor(x + s);\n        const j = fastFloor(y + s);\n        const t = (i + j) * G2;\n        const X0 = i - t; // Unskew the cell origin back to (x,y) space\n        const Y0 = j - t;\n        const x0 = x - X0; // The x,y distances from the cell origin\n        const y0 = y - Y0;\n        // For the 2D case, the simplex shape is an equilateral triangle.\n        // Determine which simplex we are in.\n        let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n        if (x0 > y0) {\n            i1 = 1;\n            j1 = 0;\n        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n        else {\n            i1 = 0;\n            j1 = 1;\n        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n        // c = (3-sqrt(3))/6\n        const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n        const y1 = y0 - j1 + G2;\n        const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n        const y2 = y0 - 1.0 + 2.0 * G2;\n        // Work out the hashed gradient indices of the three simplex corners\n        const ii = i & 255;\n        const jj = j & 255;\n        // Calculate the contribution from the three corners\n        let t0 = 0.5 - x0 * x0 - y0 * y0;\n        if (t0 >= 0) {\n            const gi0 = ii + perm[jj];\n            const g0x = permGrad2x[gi0];\n            const g0y = permGrad2y[gi0];\n            t0 *= t0;\n            // n0 = t0 * t0 * (grad2[gi0] * x0 + grad2[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient\n            n0 = t0 * t0 * (g0x * x0 + g0y * y0);\n        }\n        let t1 = 0.5 - x1 * x1 - y1 * y1;\n        if (t1 >= 0) {\n            const gi1 = ii + i1 + perm[jj + j1];\n            const g1x = permGrad2x[gi1];\n            const g1y = permGrad2y[gi1];\n            t1 *= t1;\n            // n1 = t1 * t1 * (grad2[gi1] * x1 + grad2[gi1 + 1] * y1);\n            n1 = t1 * t1 * (g1x * x1 + g1y * y1);\n        }\n        let t2 = 0.5 - x2 * x2 - y2 * y2;\n        if (t2 >= 0) {\n            const gi2 = ii + 1 + perm[jj + 1];\n            const g2x = permGrad2x[gi2];\n            const g2y = permGrad2y[gi2];\n            t2 *= t2;\n            // n2 = t2 * t2 * (grad2[gi2] * x2 + grad2[gi2 + 1] * y2);\n            n2 = t2 * t2 * (g2x * x2 + g2y * y2);\n        }\n        // Add contributions from each corner to get the final noise value.\n        // The result is scaled to return values in the interval [-1,1].\n        return 70.0 * (n0 + n1 + n2);\n    };\n}\n/**\n * Creates a 3D noise function\n * @param random the random function that will be used to build the permutation table\n * @returns {NoiseFunction3D}\n */\nfunction createNoise3D(random = Math.random) {\n    const perm = buildPermutationTable(random);\n    // precalculating these seems to yield a speedup of over 15%\n    const permGrad3x = new Float64Array(perm).map(v => grad3[(v % 12) * 3]);\n    const permGrad3y = new Float64Array(perm).map(v => grad3[(v % 12) * 3 + 1]);\n    const permGrad3z = new Float64Array(perm).map(v => grad3[(v % 12) * 3 + 2]);\n    return function noise3D(x, y, z) {\n        let n0, n1, n2, n3; // Noise contributions from the four corners\n        // Skew the input space to determine which simplex cell we're in\n        const s = (x + y + z) * F3; // Very nice and simple skew factor for 3D\n        const i = fastFloor(x + s);\n        const j = fastFloor(y + s);\n        const k = fastFloor(z + s);\n        const t = (i + j + k) * G3;\n        const X0 = i - t; // Unskew the cell origin back to (x,y,z) space\n        const Y0 = j - t;\n        const Z0 = k - t;\n        const x0 = x - X0; // The x,y,z distances from the cell origin\n        const y0 = y - Y0;\n        const z0 = z - Z0;\n        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n        // Determine which simplex we are in.\n        let i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n        let i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n        if (x0 >= y0) {\n            if (y0 >= z0) {\n                i1 = 1;\n                j1 = 0;\n                k1 = 0;\n                i2 = 1;\n                j2 = 1;\n                k2 = 0;\n            } // X Y Z order\n            else if (x0 >= z0) {\n                i1 = 1;\n                j1 = 0;\n                k1 = 0;\n                i2 = 1;\n                j2 = 0;\n                k2 = 1;\n            } // X Z Y order\n            else {\n                i1 = 0;\n                j1 = 0;\n                k1 = 1;\n                i2 = 1;\n                j2 = 0;\n                k2 = 1;\n            } // Z X Y order\n        }\n        else { // x0<y0\n            if (y0 < z0) {\n                i1 = 0;\n                j1 = 0;\n                k1 = 1;\n                i2 = 0;\n                j2 = 1;\n                k2 = 1;\n            } // Z Y X order\n            else if (x0 < z0) {\n                i1 = 0;\n                j1 = 1;\n                k1 = 0;\n                i2 = 0;\n                j2 = 1;\n                k2 = 1;\n            } // Y Z X order\n            else {\n                i1 = 0;\n                j1 = 1;\n                k1 = 0;\n                i2 = 1;\n                j2 = 1;\n                k2 = 0;\n            } // Y X Z order\n        }\n        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n        // c = 1/6.\n        const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n        const y1 = y0 - j1 + G3;\n        const z1 = z0 - k1 + G3;\n        const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords\n        const y2 = y0 - j2 + 2.0 * G3;\n        const z2 = z0 - k2 + 2.0 * G3;\n        const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords\n        const y3 = y0 - 1.0 + 3.0 * G3;\n        const z3 = z0 - 1.0 + 3.0 * G3;\n        // Work out the hashed gradient indices of the four simplex corners\n        const ii = i & 255;\n        const jj = j & 255;\n        const kk = k & 255;\n        // Calculate the contribution from the four corners\n        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n        if (t0 < 0)\n            n0 = 0.0;\n        else {\n            const gi0 = ii + perm[jj + perm[kk]];\n            t0 *= t0;\n            n0 = t0 * t0 * (permGrad3x[gi0] * x0 + permGrad3y[gi0] * y0 + permGrad3z[gi0] * z0);\n        }\n        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n        if (t1 < 0)\n            n1 = 0.0;\n        else {\n            const gi1 = ii + i1 + perm[jj + j1 + perm[kk + k1]];\n            t1 *= t1;\n            n1 = t1 * t1 * (permGrad3x[gi1] * x1 + permGrad3y[gi1] * y1 + permGrad3z[gi1] * z1);\n        }\n        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n        if (t2 < 0)\n            n2 = 0.0;\n        else {\n            const gi2 = ii + i2 + perm[jj + j2 + perm[kk + k2]];\n            t2 *= t2;\n            n2 = t2 * t2 * (permGrad3x[gi2] * x2 + permGrad3y[gi2] * y2 + permGrad3z[gi2] * z2);\n        }\n        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n        if (t3 < 0)\n            n3 = 0.0;\n        else {\n            const gi3 = ii + 1 + perm[jj + 1 + perm[kk + 1]];\n            t3 *= t3;\n            n3 = t3 * t3 * (permGrad3x[gi3] * x3 + permGrad3y[gi3] * y3 + permGrad3z[gi3] * z3);\n        }\n        // Add contributions from each corner to get the final noise value.\n        // The result is scaled to stay just inside [-1,1]\n        return 32.0 * (n0 + n1 + n2 + n3);\n    };\n}\n/**\n * Creates a 4D noise function\n * @param random the random function that will be used to build the permutation table\n * @returns {NoiseFunction4D}\n */\nfunction createNoise4D(random = Math.random) {\n    const perm = buildPermutationTable(random);\n    // precalculating these leads to a ~10% speedup\n    const permGrad4x = new Float64Array(perm).map(v => grad4[(v % 32) * 4]);\n    const permGrad4y = new Float64Array(perm).map(v => grad4[(v % 32) * 4 + 1]);\n    const permGrad4z = new Float64Array(perm).map(v => grad4[(v % 32) * 4 + 2]);\n    const permGrad4w = new Float64Array(perm).map(v => grad4[(v % 32) * 4 + 3]);\n    return function noise4D(x, y, z, w) {\n        let n0, n1, n2, n3, n4; // Noise contributions from the five corners\n        // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n        const s = (x + y + z + w) * F4; // Factor for 4D skewing\n        const i = fastFloor(x + s);\n        const j = fastFloor(y + s);\n        const k = fastFloor(z + s);\n        const l = fastFloor(w + s);\n        const t = (i + j + k + l) * G4; // Factor for 4D unskewing\n        const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n        const Y0 = j - t;\n        const Z0 = k - t;\n        const W0 = l - t;\n        const x0 = x - X0; // The x,y,z,w distances from the cell origin\n        const y0 = y - Y0;\n        const z0 = z - Z0;\n        const w0 = w - W0;\n        // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n        // To find out which of the 24 possible simplices we're in, we need to\n        // determine the magnitude ordering of x0, y0, z0 and w0.\n        // Six pair-wise comparisons are performed between each possible pair\n        // of the four coordinates, and the results are used to rank the numbers.\n        let rankx = 0;\n        let ranky = 0;\n        let rankz = 0;\n        let rankw = 0;\n        if (x0 > y0)\n            rankx++;\n        else\n            ranky++;\n        if (x0 > z0)\n            rankx++;\n        else\n            rankz++;\n        if (x0 > w0)\n            rankx++;\n        else\n            rankw++;\n        if (y0 > z0)\n            ranky++;\n        else\n            rankz++;\n        if (y0 > w0)\n            ranky++;\n        else\n            rankw++;\n        if (z0 > w0)\n            rankz++;\n        else\n            rankw++;\n        // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n        // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n        // impossible. Only the 24 indices which have non-zero entries make any sense.\n        // We use a thresholding to set the coordinates in turn from the largest magnitude.\n        // Rank 3 denotes the largest coordinate.\n        // Rank 2 denotes the second largest coordinate.\n        // Rank 1 denotes the second smallest coordinate.\n        // The integer offsets for the second simplex corner\n        const i1 = rankx >= 3 ? 1 : 0;\n        const j1 = ranky >= 3 ? 1 : 0;\n        const k1 = rankz >= 3 ? 1 : 0;\n        const l1 = rankw >= 3 ? 1 : 0;\n        // The integer offsets for the third simplex corner\n        const i2 = rankx >= 2 ? 1 : 0;\n        const j2 = ranky >= 2 ? 1 : 0;\n        const k2 = rankz >= 2 ? 1 : 0;\n        const l2 = rankw >= 2 ? 1 : 0;\n        // The integer offsets for the fourth simplex corner\n        const i3 = rankx >= 1 ? 1 : 0;\n        const j3 = ranky >= 1 ? 1 : 0;\n        const k3 = rankz >= 1 ? 1 : 0;\n        const l3 = rankw >= 1 ? 1 : 0;\n        // The fifth corner has all coordinate offsets = 1, so no need to compute that.\n        const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n        const y1 = y0 - j1 + G4;\n        const z1 = z0 - k1 + G4;\n        const w1 = w0 - l1 + G4;\n        const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\n        const y2 = y0 - j2 + 2.0 * G4;\n        const z2 = z0 - k2 + 2.0 * G4;\n        const w2 = w0 - l2 + 2.0 * G4;\n        const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\n        const y3 = y0 - j3 + 3.0 * G4;\n        const z3 = z0 - k3 + 3.0 * G4;\n        const w3 = w0 - l3 + 3.0 * G4;\n        const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\n        const y4 = y0 - 1.0 + 4.0 * G4;\n        const z4 = z0 - 1.0 + 4.0 * G4;\n        const w4 = w0 - 1.0 + 4.0 * G4;\n        // Work out the hashed gradient indices of the five simplex corners\n        const ii = i & 255;\n        const jj = j & 255;\n        const kk = k & 255;\n        const ll = l & 255;\n        // Calculate the contribution from the five corners\n        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\n        if (t0 < 0)\n            n0 = 0.0;\n        else {\n            const gi0 = ii + perm[jj + perm[kk + perm[ll]]];\n            t0 *= t0;\n            n0 = t0 * t0 * (permGrad4x[gi0] * x0 + permGrad4y[gi0] * y0 + permGrad4z[gi0] * z0 + permGrad4w[gi0] * w0);\n        }\n        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\n        if (t1 < 0)\n            n1 = 0.0;\n        else {\n            const gi1 = ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]];\n            t1 *= t1;\n            n1 = t1 * t1 * (permGrad4x[gi1] * x1 + permGrad4y[gi1] * y1 + permGrad4z[gi1] * z1 + permGrad4w[gi1] * w1);\n        }\n        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\n        if (t2 < 0)\n            n2 = 0.0;\n        else {\n            const gi2 = ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]];\n            t2 *= t2;\n            n2 = t2 * t2 * (permGrad4x[gi2] * x2 + permGrad4y[gi2] * y2 + permGrad4z[gi2] * z2 + permGrad4w[gi2] * w2);\n        }\n        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\n        if (t3 < 0)\n            n3 = 0.0;\n        else {\n            const gi3 = ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]];\n            t3 *= t3;\n            n3 = t3 * t3 * (permGrad4x[gi3] * x3 + permGrad4y[gi3] * y3 + permGrad4z[gi3] * z3 + permGrad4w[gi3] * w3);\n        }\n        let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\n        if (t4 < 0)\n            n4 = 0.0;\n        else {\n            const gi4 = ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]];\n            t4 *= t4;\n            n4 = t4 * t4 * (permGrad4x[gi4] * x4 + permGrad4y[gi4] * y4 + permGrad4z[gi4] * z4 + permGrad4w[gi4] * w4);\n        }\n        // Sum up and scale the result to cover the range [-1,1]\n        return 27.0 * (n0 + n1 + n2 + n3 + n4);\n    };\n}\n/**\n * Builds a random permutation table.\n * This is exported only for (internal) testing purposes.\n * Do not rely on this export.\n * @private\n */\nfunction buildPermutationTable(random) {\n    const tableSize = 512;\n    const p = new Uint8Array(tableSize);\n    for (let i = 0; i < tableSize / 2; i++) {\n        p[i] = i;\n    }\n    for (let i = 0; i < tableSize / 2 - 1; i++) {\n        const r = i + ~~(random() * (256 - i));\n        const aux = p[i];\n        p[i] = p[r];\n        p[r] = aux;\n    }\n    for (let i = 256; i < tableSize; i++) {\n        p[i] = p[i - 256];\n    }\n    return p;\n}\n//# sourceMappingURL=simplex-noise.js.map\n\n//# sourceURL=webpack:///./node_modules/simplex-noise/dist/esm/simplex-noise.js?");

/***/ }),

/***/ "./src/colormap.js":
/*!*************************!*\
  !*** ./src/colormap.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   discretebiomes: () => (/* binding */ discretebiomes),\n/* harmony export */   gray: () => (/* binding */ gray),\n/* harmony export */   grayblue: () => (/* binding */ grayblue),\n/* harmony export */   greengray: () => (/* binding */ greengray),\n/* harmony export */   smoothbiomes: () => (/* binding */ smoothbiomes),\n/* harmony export */   terrainbands: () => (/* binding */ terrainbands),\n/* harmony export */   waterlevel: () => (/* binding */ waterlevel)\n/* harmony export */ });\n// From http://www.redblobgames.com/\n// Copyright 2015 Red Blob Games <redblobgames@gmail.com>\n// License: Apache v2.0 <http://www.apache.org/licenses/LICENSE-2.0.html>\n\n/* A set of colormaps for use with the rendering functions.\n *\n * A colormap is a function that takes (x,y,z) and returns [r,g,b].\n * Annoyingly, x,y are integers in map coordinates and z is 0.0-1.0.\n */\n\nfunction lookup(array) {\n    return function(_x, _y, z) {\n        let index = (255 * z) | 0;\n        if (index < 0) { index = 0; }\n        if (index > 255) { index = 255; }\n        return array[index];\n    };\n}\n\nfunction gray() {\n    let c = [];\n    for (let i = 0; i < 256; i++) {\n        c.push([i, i, i]);\n    }\n    return lookup(c);\n}\n\n\nfunction greengray() {\n    let c = [];\n    for (let i = 0; i < 256; i++) {\n        c.push([i*0.6 + 0.4*255,\n                i*0.5 + 0.5*255,\n                i*0.6 + 0.4*255]);\n    }\n    return lookup(c);\n}\n\n\nfunction grayblue() {\n    let c = [];\n    for (let i = 0; i < 256; i++) {\n        c.push([i*0.6 + 0.1*255,\n                i*0.7 + 0.1*255,\n                i*1.0 + 0.1*255]);\n    }\n    return lookup(c);\n}\n\n\nfunction waterlevel(terrain) {\n    let level = 0;\n    const water = [96, 128, 255];\n    function c(x, y, z) {\n        if (z <= level/255) {\n            let darken = (level - z*255)/2;\n            return [Math.max(0, water[0]-darken),\n                    Math.max(0, water[1]-darken),\n                    Math.max(0, water[2]-darken)];\n        } else {\n            return terrain(x, y, (z-(level/255)) * (255/(255-level)));\n        }\n    };\n\n    c.setLevel = function(newLevel) { level = newLevel; };\n    return c;\n}\n\n\nfunction terrainbands() {\n    const deepwater = [64, 96, 192];\n    const shallowwater = [96, 128, 255];\n    const beach = [209, 180, 144];\n    const forest = [116, 169, 99];\n    const jungle = [65, 126, 98];\n    const savannah = [164, 189, 125];\n    const desert = [190, 210, 175];\n    const snow = [210, 210, 215];\n    \n    return function(_x, _y, z) {\n        if (z < 0.003) return deepwater;\n        if (z < 0.004) return shallowwater;\n        if (z < 0.004) return beach;\n        if (z < 0.100) return forest;\n        if (z < 0.300) return jungle;\n        if (z < 0.600) return savannah;\n        if (z < 0.900) return desert;\n        return snow;\n    };\n}\n\n\nfunction discretebiomes(elevation, moisture) {\n    // From mapgen2\n    const biome = {\n      // Features\n      OCEAN: 0x44447a,\n      COAST: 0x33335a,\n      LAKESHORE: 0x225588,\n      LAKE: 0x336699,\n      RIVER: 0x225588,\n      MARSH: 0x2f6666,\n      ICE: 0x99ffff,\n      BEACH: 0xa09077,\n      ROAD1: 0x442211,\n      ROAD2: 0x553322,\n      ROAD3: 0x664433,\n      BRIDGE: 0x686860,\n      LAVA: 0xcc3333,\n\n      // Terrain\n      SNOW: 0xdddde4,\n      TUNDRA: 0xbbbbaa,\n      BARE: 0x888888,\n      SCORCHED: 0x555555,\n      TAIGA: 0x99aa77,\n      SHRUBLAND: 0x889977,\n      TEMPERATE_DESERT: 0xc9d29b,\n      TEMPERATE_RAIN_FOREST: 0x448855,\n      TEMPERATE_DECIDUOUS_FOREST: 0x679459,\n      GRASSLAND: 0x88aa55,\n      SUBTROPICAL_DESERT: 0xd2b98b,\n      TROPICAL_RAIN_FOREST: 0x337755,\n      TROPICAL_SEASONAL_FOREST: 0x559944\n    };\n\n    function biomeColor(z, m) {\n        if (z < 0.1) return biome.OCEAN;\n        if (z < 0.12) return biome.BEACH;\n        \n        if (z > 0.8) {\n            if (m < 0.1) return biome.SCORCHED;\n            if (m < 0.2) return biome.BARE;\n            if (m < 0.5) return biome.TUNDRA;\n            return biome.SNOW;\n        }\n\n        if (z > 0.6) {\n            if (m < 0.33) return biome.TEMPERATE_DESERT;\n            if (m < 0.66) return biome.SHRUBLAND;\n            return biome.TAIGA;\n        }\n\n        if (z > 0.3) {\n            if (m < 0.16) return biome.TEMPERATE_DESERT;\n            if (m < 0.50) return biome.GRASSLAND;\n            if (m < 0.83) return biome.TEMPERATE_DECIDUOUS_FOREST;\n            return biome.TEMPERATE_RAIN_FOREST;\n        }\n\n        if (m < 0.16) return biome.SUBTROPICAL_DESERT;\n        if (m < 0.33) return biome.GRASSLAND;\n        if (m < 0.66) return biome.TROPICAL_SEASONAL_FOREST;\n        return biome.TROPICAL_RAIN_FOREST;\n    }\n    \n    return function(x, y, _z) {\n        // Use the original elevation, not the one modified by an\n        // exponent, because the z ranges I defined in mapgen2 are for\n        // the unmodified z. Also, I need to reshape these ranges a\n        // bit because in mapgen2 I redistribute elevations and\n        // moistures, and here I am directly getting it from the\n        // perlin noise, which isn't evenly distributed.\n        let z = elevation.get(x, y);\n        let m = moisture.get(x, y);\n        // Reshape these because perlin noise isn't evenly distributed\n        z = z * 1.4 - 0.35;\n        m = m * 3.0 - 1.0;\n        \n        let color = biomeColor(z, m);\n        return [color >> 16, (color >> 8) & 255, color & 255];\n    };\n}\n\nfunction smoothbiomes(elevation, moisture) {\n    let water = 0.1;\n    return function(x, y, _) {\n        let z = elevation.get(x, y);\n        let m = moisture.get(x, y);\n        // Reshape these because perlin noise isn't evenly distributed\n        z = z * 1.3 - 0.35;\n        m = m * 3.0 - 0.7;\n\n        if (z < water) {\n            return [48 + 48*z/water, 64 + 64*z/water, 127 + 128*z/water];\n        }\n\n        // Green or brown at low elevation, and make it more white-ish\n        // as you go up\n        z = z * z * 0.7;\n        let r = 210 - 100*m, g = 185 - 45*m, b = 139 - 45*m;\n        return [255 * z + r * (1-z),\n                255 * z + g * (1-z),\n                255 * z + b * (1-z)];\n    };\n}\n\n\n//# sourceURL=webpack:///./src/colormap.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _map2d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map2d.js */ \"./src/map2d.js\");\n/* harmony import */ var _render2d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./render2d.js */ \"./src/render2d.js\");\n/* harmony import */ var _render3d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./render3d.js */ \"./src/render3d.js\");\n/* harmony import */ var _renderboth_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderboth.js */ \"./src/renderboth.js\");\n/* harmony import */ var _colormap_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./colormap.js */ \"./src/colormap.js\");\n/* harmony import */ var _simplemapgen_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./simplemapgen.js */ \"./src/simplemapgen.js\");\n/* harmony import */ var _prng_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./prng.js */ \"./src/prng.js\");\n/* harmony import */ var _noise_utils_ts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./noise-utils.ts */ \"./src/noise-utils.ts\");\n/* harmony import */ var _visualize_reshaper_ts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./visualize-reshaper.ts */ \"./src/visualize-reshaper.ts\");\n\n\n\n\n\n\n\n\n// If using TypeScript files\n\n\n\n// Debugging to verify the script runs\nconsole.log(\"All modules loaded!\");\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/map2d.js":
/*!**********************!*\
  !*** ./src/map2d.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Map2D)\n/* harmony export */ });\n// From http://www.redblobgames.com/\n// Copyright 2015 Red Blob Games <redblobgames@gmail.com>\n// License: Apache v2.0 <http://www.apache.org/licenses/LICENSE-2.0.html>\n\n/** Representation of 2D maps with float data\n *\n * Fields:\n *   w:int, h:int, size:int -- read-only\n *   data:array[size]:float -- read/write\n * Methods:\n *   id(x:int, y:int):int -- tells you where in data[] (x,y) goes\n *   x(id:int):int -- tells you the x for a given id\n *   y(id:int):int -- tells you the y for a given id\n *   get(x:int, y:int):float -- getter\n *   set(x:int, y:int, value:float) -- setter\n *\n * It is fine to directly read/write from the data array.\n */\n\nclass Map2D {\n    constructor(w, h) {\n        this.w = w;\n        this.h = h;\n        this.size = w * h;\n        this.data = new Float32Array(this.size);\n    }\n    id(x, y)         { return x + this.w * y; }\n    x(id)            { return id % this.w; }\n    y(id)            { return (id / this.w) | 0; }\n    get(x, y)        { return this.data[this.id(x, y)]; }\n    set(x, y, value) { this.data[this.id(x, y)] = value; }\n    \n    // Radially decreasing intensity added centered at x, y\n    // Clamps to max 1 intensity\n    brush(x, y, r, intensity=0.2) {\n      let min_x = Math.max(0, x-r+1);\n      let max_x = Math.min(this.w, x+r-1);\n      let r2 = r*r;\n\n      // Square Brush\n      // for (let ix=min_x; ix<=max_x; ix++) {\n      //   for (let iy=min_y; iy<=max_y; iy++) {\n      //     console.log(ix, iy);\n      //     this.set(ix, iy, 1);\n      //   }\n      // }\n\n      // Sweep over all suitable x values\n      for (let cur_x = min_x; cur_x <= max_x; cur_x++) {\n        let dist_x = r2 - (Math.abs(x - cur_x)**2);\n        let del_y = Math.sqrt(dist_x);\n        let min_y = Math.max(0, y-del_y+1);\n        let max_y = Math.min(this.h, y+del_y-1);\n\n        // Sweep over all suitable y values\n        for (let cur_y = min_y; cur_y <= max_y; cur_y++) {\n          let dist = Math.sqrt(dist_x - (Math.abs(y - cur_y) ** 2));\n          let del_z = intensity * (dist / r)**2;\n          let ix = Math.round(cur_x);\n          let iy = Math.round(cur_y);\n\n          this.set(ix, iy, this.get(ix, iy) + del_z);\n        }\n      }\n    }\n}\n\n\n//# sourceURL=webpack:///./src/map2d.js?");

/***/ }),

/***/ "./src/noise-utils.ts":
/*!****************************!*\
  !*** ./src/noise-utils.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SEED: () => (/* binding */ SEED),\n/* harmony export */   SimplexNoise2D: () => (/* binding */ SimplexNoise2D),\n/* harmony export */   SimplexNoise3D: () => (/* binding */ SimplexNoise3D),\n/* harmony export */   SimplexNoise4D: () => (/* binding */ SimplexNoise4D),\n/* harmony export */   addMaps: () => (/* binding */ addMaps),\n/* harmony export */   fillNoise: () => (/* binding */ fillNoise),\n/* harmony export */   makeNoise: () => (/* binding */ makeNoise),\n/* harmony export */   mixNoise: () => (/* binding */ mixNoise),\n/* harmony export */   reshapeNoiseExponent: () => (/* binding */ reshapeNoiseExponent)\n/* harmony export */ });\n/* harmony import */ var simplex_noise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! simplex-noise */ \"./node_modules/simplex-noise/dist/esm/simplex-noise.js\");\n/* harmony import */ var _prng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prng.js */ \"./src/prng.js\");\n/* harmony import */ var _map2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map2d.js */ \"./src/map2d.js\");\n/*\n * From https://www.redblobgames.com/maps/terrain-from-noise/\n * Copyright 2015 Red Blob Games <redblobgames@gmail.com>\n * License: Apache-2.0 <http://www.apache.org/licenses/LICENSE-2.0.html>\n */\n\n// @ts-ignore\n\n// @ts-ignore\n\nconst SEED = 12345;\nfunction SimplexNoise2D(seed) { return (0,simplex_noise__WEBPACK_IMPORTED_MODULE_0__.createNoise2D)((0,_prng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(seed)); }\nfunction SimplexNoise3D(seed) { return (0,simplex_noise__WEBPACK_IMPORTED_MODULE_0__.createNoise3D)((0,_prng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(seed)); }\nfunction SimplexNoise4D(seed) { return (0,simplex_noise__WEBPACK_IMPORTED_MODULE_0__.createNoise4D)((0,_prng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(seed)); }\n/** Make a new map with noise, and cache previously generated maps */\nlet mapCache = new Map();\nfunction makeNoise(width, height, frequency, seed) {\n    const cacheKey = `${seed}:${width}:${height}:${frequency}`;\n    if (!mapCache.has(cacheKey)) {\n        let map = new _map2d_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](width, height);\n        fillNoise(map, frequency, seed);\n        mapCache.set(cacheKey, map);\n    }\n    return mapCache.get(cacheKey);\n}\n/** Fill a map with one frequency of noise values from 0.0 to 1.0 */\nfunction fillNoise(output, frequency, seed) {\n    const noise = SimplexNoise2D(seed);\n    const aspect = output.w / output.h;\n    for (let y = 0; y < output.h; y++) {\n        for (let x = 0; x < output.w; x++) {\n            let nx = x / output.w - 0.5, ny = y / output.h - 0.5;\n            let z = noise(nx * frequency * aspect, ny * frequency);\n            output.set(x, y, z / 2 + 0.5);\n        }\n    }\n}\n/** Add multiple noise maps together */\nfunction addMaps(output, maps, amplitudes) {\n    const N = maps.length;\n    if (N !== amplitudes.length) {\n        throw `map count (${N}) and amplitude count (${amplitudes.length}) must be the same`;\n    }\n    for (let y = 0; y < output.h; y++) {\n        for (let x = 0; x < output.w; x++) {\n            let z = 0;\n            for (let i = 0; i < N; i++) {\n                z += amplitudes[i] * maps[i].get(x, y);\n            }\n            output.set(x, y, z);\n        }\n    }\n}\n/** Mix together several frequencies of simplex noise */\nfunction mixNoise(output, spectrum, frequency, seed = SEED) {\n    let maps = [];\n    let scale = 0.0;\n    let amplitudes = [];\n    for (let octave = 0, exponent = 1; octave < spectrum.length; octave++, exponent *= 2) {\n        scale += spectrum[octave];\n        maps.push(makeNoise(output.w, output.h, frequency * exponent, seed + octave));\n        amplitudes.push(spectrum[octave]);\n    }\n    addMaps(output, maps, amplitudes.map(function (a) { return a / scale; }));\n}\n/** Reshape noise by a power function */\nfunction reshapeNoiseExponent(output, input, exponent) {\n    const size = input.size;\n    for (let id = 0; id < size; id++) {\n        // The 1.21 is a fudge factor I needed to make scale better; see\n        // https://digitalfreepen.com/2017/06/20/range-perlin-noise.html\n        // for justification: the range of noise is sqrt(num_dimensions/4)\n        output.data[id] = Math.pow(1.21 * input.data[id], exponent);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/noise-utils.ts?");

/***/ }),

/***/ "./src/prng.js":
/*!*********************!*\
  !*** ./src/prng.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ makeRand)\n/* harmony export */ });\n/*\n * From https://www.redblobgames.com/maps/terrain-from-noise/\n * Copyright 2022 Red Blob Games <redblobgames@gmail.com>\n * @license Apache-2.0 <https://www.apache.org/licenses/LICENSE-2.0.html>\n */\n\n\nfunction makeRand(seed) {\n    // https://en.wikipedia.org/wiki/Lehmer_random_number_generator\n    return function() {\n        const wrap = 0x7FFFFFFF;\n        seed = seed * 48271 % wrap;\n        return (seed - 1) / (wrap - 1);\n    };\n}\n    \n\n\n//# sourceURL=webpack:///./src/prng.js?");

/***/ }),

/***/ "./src/render-common.js":
/*!******************************!*\
  !*** ./src/render-common.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   draw: () => (/* binding */ draw)\n/* harmony export */ });\n// From http://www.redblobgames.com/\n// Copyright 2015 Red Blob Games <redblobgames@gmail.com>\n// License: Apache v2.0 <http://www.apache.org/licenses/LICENSE-2.0.html>\n\n/* Image handling common to 2D and 3D rendering\n *\n * I'm saving all the images to static files, and using those files on\n * startup. When the diagram needs to be redrawn, I replace the <img>\n * with a <canvas> and draw it.\n *\n * This makes the page load much faster, and it also will work if\n * Javascript is disabled.\n *\n * In \"generate\" mode, I draw the diagrams and save them to files.\n * I'll use this during development if the drawing style has changed.\n * It would be nice to automate this; maybe later.\n */\n\n// Use special parameter #cache to regenerate images to send to server\nconst SAVE_IMAGES = document.location.hash.match(/#repopulate-cache/);\nif (SAVE_IMAGES) { setTimeout(() => window.close(), 30000); }\n\n/** Draw logic:\n *\n * If there's already a canvas with the given id, use it for drawing.\n * Skip the caching behavior. Otherwise:\n *\n * If SAVE_IMAGES is set, skip the image cache. Save the image to\n * a file by sending it to a localhost server.\n *\n * Otherwise, assume there's an <img> with the same name that acts as\n * the cached copy. The first draw will keep the cached version. The\n * second draw will replace the <img> with a <canvas>. Subsequent\n * calls will draw to the canvas.\n *\n * Since many of the diagrams on the page are static, and even the\n * dynamic ones don't get any interaction, we can use the cached copy\n * most of the time.\n */\nfunction draw() {\n    // If there's already a canvas, short circuit all the caching logic.\n    let canvas = document.getElementById(this.elementId);\n    if (canvas?.tagName === \"CANVAS\") {\n        this.canvas = canvas;\n        this.draw = this._draw;\n        this.setup();\n        this.draw();\n        return;\n    }\n\n    // But if there isn't a canvas with this id, assume there's an\n    // image that loads from render-${id}. Skip the *first* draw call\n    // because we're using the cached image. But after this, we'll draw.\n    this.draw = switch_to_canvas_and_draw;\n    if (SAVE_IMAGES) {\n        this.draw();\n        console.log(\"Saving\", this.elementId);\n        fetch(\"http://localhost:8000/\" + this.elementId, {\n            method: 'POST',\n            mode: 'no-cors',\n            credentials: 'same-origin',\n            headers: {'Content-Type': 'text/plain'},\n            body: this.canvas.toDataURL('image/png')\n        });\n    }\n}\n\nfunction switch_to_canvas_and_draw() {\n    // This is the second draw. The <img> only captures the\n    // diagram on the first draw, so we can't use it anymore.\n    // Replace it with a <canvas> and then regenerate the diagram.\n    const img = findImageOnPage(this.elementId);\n    this.canvas = createCanvas(this.elementId, img.getAttribute('width'), img.getAttribute('height'));\n    \n    // Only replace the image if we're able to get a drawing\n    // context. This is especially important for WebGL, which\n    // is not as widely supported as Canvas.\n    if (!this.getContext()) {\n        console.log(\"error: could not create drawing context for #\", this.elementId);\n        this.draw = function() {};\n        return;\n    }\n\n    // Replace the image with the canvas\n    img.parentNode.insertBefore(this.canvas, img);\n    img.parentNode.removeChild(img);\n\n    // Prepare for drawing\n    this.setup();\n\n    // Replace ourselves\n    this.draw = this._draw;\n\n    this.draw();\n};\n\n\n/** Create a <canvas> element for drawing\n\n    1. Find an <img src=\"images/$id.png\"> and replace it by <canvas>.\n    2. Set this.canvas to the new canvas element.\n    3. The containing class should have this.getContext() to return\n       a drawing context. If it can't make one, don't replace the img.\n */\n    \n/** Find and return <img src=\"images/$id.png?…\"> */\nfunction findImageOnPage(elementId) {\n    const images = document.getElementsByTagName('img');\n    for (let img of images) {\n        let url = img.src.replace(/\\?.*$/, '').split('/');\n        if (url[url.length-1] == elementId + '.png') {\n            return img;\n        }\n    }\n    return null;\n}\n\n/** Create canvas */\nfunction createCanvas(elementId, width, height) {\n    const canvas = document.createElement('canvas');\n    canvas.setAttribute('id', elementId);\n    canvas.setAttribute('width', width);\n    canvas.setAttribute('height', height);\n    return canvas;\n}\n\n\n//# sourceURL=webpack:///./src/render-common.js?");

/***/ }),

/***/ "./src/render2d.js":
/*!*************************!*\
  !*** ./src/render2d.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Renderer)\n/* harmony export */ });\n/* harmony import */ var _render_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render-common.js */ \"./src/render-common.js\");\n// From http://www.redblobgames.com/\n// Copyright 2015 Red Blob Games <redblobgames@gmail.com>\n// License: Apache v2.0 <http://www.apache.org/licenses/LICENSE-2.0.html>\n\n/* Render a 2D array (from map2d.js) to a canvas\n *\n * Render the map to an off-screen buffer, then scale it up or down\n * when rendering to the screen.\n */\n\n\n\n\nclass Renderer {\n    constructor(elementId, map, colorMap) {\n        this.draw = _render_common_js__WEBPACK_IMPORTED_MODULE_0__.draw;\n        this.elementId = elementId;\n        this.map = map;\n        this.colorMap = colorMap;\n    }\n    \n    setup() {\n        this.buffer = document.createElement('canvas');\n        this.buffer.width = this.map.w;\n        this.buffer.height = this.map.h;\n    }\n    \n    getContext() {\n        return this.canvas.getContext('2d');\n    }\n    \n    _draw() {\n        this._drawToBuffer();\n\n        this.canvas.width = this.buffer.width;\n        this.canvas.height = this.buffer.height;\n        let ctx = this.getContext();\n        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.save();\n        ctx.scale(this.canvas.width / this.buffer.width,\n                  this.canvas.height / this.buffer.height);\n        ctx.drawImage(this.buffer, 0, 0);\n        ctx.restore();\n    }\n    \n    _drawToBuffer() {\n        const {map, colorMap} = this;\n        const {w, h} = map;\n        let ctx = this.buffer.getContext('2d', {willReadFrequently: true});\n        let imageData = ctx.getImageData(0, 0, w, h);\n        let pixels = imageData.data;\n\n        for (let y = 0; y < h; y++) {\n            for (let x = 0; x < w; x++) {\n                let p = 4 * (y * w + x);\n                let c = colorMap(x, y, map.get(x, y));\n                for (let i = 0; i < 3; i++) {\n                    pixels[p + i] = c[i];\n                }\n                pixels[p + 3] = 255;\n            }\n        }\n        ctx.putImageData(imageData, 0, 0);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/render2d.js?");

/***/ }),

/***/ "./src/render3d.js":
/*!*************************!*\
  !*** ./src/render3d.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Renderer)\n/* harmony export */ });\n/* harmony import */ var _render_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render-common.js */ \"./src/render-common.js\");\n// From http://www.redblobgames.com/\n// Copyright 2015 Red Blob Games <redblobgames@gmail.com>\n// License: Apache v2.0 <http://www.apache.org/licenses/LICENSE-2.0.html>\n\n/* Render a 2D array to webgl\n *\n * A lot of this code is copied from my noise tutorial.\n *\n * IF YOU TRY TO READ THIS CODE YOU WILL GO CRAZY. It's awful code\n * that evolved from some other awful code. Maybe one day I'll rewrite it.\n */\n\n\n\nconst lightSource1 = {x: 0.2, y: 0.5, z:-0.6};\nconst lightSource2 = {x:-0.7, y:-0.2, z:-0.5};\n\nclass Renderer {\n    constructor(elementId, map, colorMap) {\n        this.draw = _render_common_js__WEBPACK_IMPORTED_MODULE_0__.draw;\n        this.elementId = elementId;\n        this.map = map;\n        this.colorMap = colorMap;\n    }\n    \n    setup() {\n        this.gl = this.getContext();\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clearColor(1.0, 1.0, 1.0, 1.0);\n        this.gl.enable(this.gl.DEPTH_TEST);\n\n        this.initShaders();\n        this.initBuffers();\n    }\n    \n    getContext() {\n        const options = { preserveDrawingBuffer: true };\n        return this.canvas.getContext('webgl', options);\n    }\n    \n    initShaders() {\n        const {gl} = this;\n        const fs = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fs, [\n            \"precision mediump float;\",\n            \"varying vec3 color;\",\n            \"void main() {\",\n            \"gl_FragColor = vec4(color, 1);\",\n            \"}\"\n        ].join(\"\\n\"));\n        gl.compileShader(fs);\n\n        const vs = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vs, [\n            \"precision mediump float;\",\n            \"uniform mat4 camera;\",\n            \"attribute vec3 c;\",\n            \"attribute vec3 d;\",\n            \"varying vec3 color;\",\n            \"void main() {\",\n            \"color = c;\",\n            \"gl_Position = camera * vec4(d.x, d.y, d.z, 1.0);\",\n            \"}\"\n        ].join(\"\\n\"));\n        gl.compileShader(vs);\n\n        this.shader = gl.createProgram();\n        gl.attachShader(this.shader, fs);\n        gl.attachShader(this.shader, vs);\n        gl.linkProgram(this.shader);\n        gl.useProgram(this.shader);\n    }\n    \n    initBuffers() {\n        const {gl} = this;\n        this.C = new Float32Array(this.map.w * this.map.h * 36);\n        this.D = new Float32Array(this.map.w * this.map.h * 36);\n        this.Cb = gl.createBuffer();\n        this.Db = gl.createBuffer();\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.Cb);\n        gl.bufferData(gl.ARRAY_BUFFER, this.C, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.Db);\n        gl.bufferData(gl.ARRAY_BUFFER, this.D, gl.DYNAMIC_DRAW);\n\n        this.c_attribute = gl.getAttribLocation(this.shader, \"c\");\n        gl.enableVertexAttribArray(this.c_attribute);\n        gl.vertexAttribPointer(this.c_attribute, 3, gl.FLOAT, false, 0, 0);\n\n        this.d_attribute = gl.getAttribLocation(this.shader, \"d\");\n        gl.enableVertexAttribArray(this.d_attribute);\n        gl.vertexAttribPointer(this.d_attribute, 3, gl.FLOAT, false, 0, 0);\n\n        this.camera_uniform = gl.getUniformLocation(this.shader, \"camera\");\n    }\n    \n    updateBuffers() {\n        const {gl, map, colorMap} = this;\n        let {D, C} = this;\n        let base = [-map.w / 2, -map.h / 2, 50];\n        let p = 0, q = 0; // pointer into D and C arrays\n        let heightscale = -map.h / 2;\n\n        function addTriangle(v, c) {\n            let x1 = v[0][0], y1 = v[0][1], z1 = v[0][2], x2 = v[1][0], y2 = v[1][1], z2 = v[1][2], x3 = v[2][0], y3 = v[2][1], z3 = v[2][2];\n            D[p++] = base[0] + x1; D[p++] = base[1] + y1; D[p++] = base[2] + z1;\n            D[p++] = base[0] + x2; D[p++] = base[1] + y2; D[p++] = base[2] + z2;\n            D[p++] = base[0] + x3; D[p++] = base[1] + y3; D[p++] = base[2] + z3;\n\n            // cross product, then get normal vector (but unnormalized for I am lazy)\n            let ux = x2 - x1, uy = y2 - y1, uz = z2 - z1, vx = x3 - x1, vy = y3 - y1, vz = z3 - z1;\n            let cx = uy * vz - uz * vy, cy = ux * vz - uz * vx, cz = ux * vy - uy * vx;\n            // dot with light vector (also unnormalized for I am lazy)\n            let dot1 = cx * lightSource1.x + cy * lightSource1.y + cz * lightSource1.z;\n            let dot2 = cx * lightSource2.x + cy * lightSource2.y + cz * lightSource2.z;\n            if (dot1 < 0.0)\n                dot1 = 0.0;\n            if (dot2 < 0.0)\n                dot2 = 0.0;\n            let light = 0.8 + 0.1 * dot1 + 0.2 * dot2;\n\n            for (let k = 0; k < 3; k++) {\n                C[q++] = light * c[k][0] / 255; C[q++] = light * c[k][1] / 255; C[q++] = light * c[k][2] / 255;\n            }\n        }\n\n        function z(x, y) { return heightscale * map.get(x, y); }\n        function c(x, y) { return colorMap(x, y, map.get(x, y)); }\n        let V1 = [0, 0, 0], V2 = [0, 0, 0], V3 = [0, 0, 0], V = [V1, V2, V3];\n        for (let x = 0; x < map.w - 2; x++) {\n            for (let y = 0; y < map.h - 2; y++) {\n                // Each 2x2 block will turn into 4 right triangles, with\n                // x+1,y+1 shared among all of them\n                let z11 = z(x + 1, y + 1), c11 = c(x + 1, y + 1), z00 = z(x, y), c00 = c(x, y), z20 = z(x + 2, y), c20 = c(x + 2, y), z02 = z(x, y + 2), c02 = c(x, y + 2), z22 = z(x + 2, y + 2), c22 = c(x + 2, y + 2);\n\n                V1[0] = x + 1; V1[1] = y + 1; V1[2] = z11;\n                V2[0] = x; V2[1] = y; V2[2] = z00;\n                V3[0] = x + 2; V3[1] = y; V3[2] = z20;\n                addTriangle(V, [c11, c00, c20]);\n                V2[0] = x; V2[1] = y + 2; V2[2] = z02;\n                V3[0] = x; V3[1] = y; V3[2] = z00;\n                addTriangle(V, [c11, c02, c00]);\n                V2[0] = x + 2; V2[1] = y; V2[2] = z20;\n                V3[0] = x + 2; V3[1] = y + 2; V3[2] = z22;\n                addTriangle(V, [c11, c20, c22]);\n                V2[0] = x + 2; V2[1] = y + 2; V2[2] = z22;\n                V3[0] = x; V3[1] = y + 2; V3[2] = z02;\n                addTriangle(V, [c11, c22, c02]);\n            }\n        }\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.Cb);\n        gl.bufferData(gl.ARRAY_BUFFER, C, gl.DYNAMIC_DRAW);\n        gl.vertexAttribPointer(this.c_attribute, 3, gl.FLOAT, false, 0, 0);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.Db);\n        gl.bufferData(gl.ARRAY_BUFFER, D, gl.DYNAMIC_DRAW);\n        gl.vertexAttribPointer(this.d_attribute, 3, gl.FLOAT, false, 0, 0);\n    }\n    \n    _draw() {\n        const {gl} = this;\n        let s = 0.2 * Math.PI;\n        let t = 0.4 * Math.PI;\n        let a = Math.cos(t), b = Math.sin(t), c = Math.cos(s), d = Math.sin(s);\n        let k = 1.7 / Math.max(this.map.w, this.map.h);\n        let xScale = k, yScale = k * 2.0, zScale = k * 0.01;\n        this.camera = [b * xScale, a * c * yScale, a * d * zScale, 0,\n        a * xScale, -b * c * yScale, -b * d * zScale, 0,\n            0, -d * yScale, c * zScale, 0,\n            0, 0, 0, 1];\n\n        this.updateBuffers();\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n        gl.uniformMatrix4fv(this.camera_uniform, false, this.camera);\n        gl.drawArrays(gl.TRIANGLES, 0, this.C.length / 3);\n\n        gl.flush();\n    }\n}\n\n\n//# sourceURL=webpack:///./src/render3d.js?");

/***/ }),

/***/ "./src/renderboth.js":
/*!***************************!*\
  !*** ./src/renderboth.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Renderer)\n/* harmony export */ });\n/* harmony import */ var _render2d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render2d.js */ \"./src/render2d.js\");\n/* harmony import */ var _render3d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./render3d.js */ \"./src/render3d.js\");\n// From http://www.redblobgames.com/\n// Copyright 2015 Red Blob Games <redblobgames@gmail.com>\n// License: Apache v2.0 <http://www.apache.org/licenses/LICENSE-2.0.html>\n\n/** Render to both a 2D and 3D canvas */\n\n\n\n\nclass Renderer {\n    constructor(elementId, map, colorMap) {\n        this.r2 = new _render2d_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](elementId + \"-2d\", map, colorMap);\n        this.r3 = new _render3d_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](elementId + \"-3d\", map, colorMap);\n    }\n    \n    draw() {\n        this.r2.draw();\n        this.r3.draw();\n    }\n}\n\n\n//# sourceURL=webpack:///./src/renderboth.js?");

/***/ }),

/***/ "./src/simplemapgen.js":
/*!*****************************!*\
  !*** ./src/simplemapgen.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _visualize_reshaper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./visualize-reshaper */ \"./src/visualize-reshaper.ts\");\n/* harmony import */ var _map2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map2d */ \"./src/map2d.js\");\n/* harmony import */ var _render2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./render2d */ \"./src/render2d.js\");\n/* harmony import */ var _render3d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./render3d */ \"./src/render3d.js\");\n/* harmony import */ var _renderboth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderboth */ \"./src/renderboth.js\");\n/* harmony import */ var _noise_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./noise-utils */ \"./src/noise-utils.ts\");\n/* harmony import */ var _colormap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./colormap */ \"./src/colormap.js\");\n// From https://www.redblobgames.com/maps/terrain-from-noise/\n// Copyright 2015 Red Blob Games <redblobgames@gmail.com>\n// License: Apache v2.0 <https://www.apache.org/licenses/LICENSE-2.0.html>\n\nconsole.info(\"I'm happy to answer questions about the code; email me at redblobgames@gmail.com\");\n\n\n\n\n\n\n\n\n\n/** Convenience wrapper around slider controls:\n\n    There should be an <input id=$elementId type=range ...>\n    and there can be any number of <span class=$elementId>\n    to receive the output values\n */\nclass Slider {\n    constructor(elementId, callback) {\n        this.callback = callback;\n        this.elementId = elementId;\n        this.slider = document.getElementById(elementId);\n        this.slider.addEventListener('input', () => this.updateFromSlider());\n        this.digits = 2;\n        this.value = this.slider.valueAsNumber;\n        this.min = this.slider.min;\n        this.max = this.slider.max;\n\n        this.outputs = document.querySelectorAll(\".\" + this.elementId);\n        this.constructScrubbables();\n\n        this.updating = false;\n    }\n\n    updateFromSlider() {\n        if (!this.updating) {\n            this.updating = true;\n            requestAnimationFrame(() => {\n                this.updating = false;\n                this.value = this.slider.valueAsNumber;\n                this.updateOutputs();\n                this.callback();\n            });\n        }\n    }\n\n    constructScrubbables() {\n        // See https://www.redblobgames.com/making-of/draggable/\n        let dragging = null;\n        for (let el of this.outputs) {\n            const start = (event) => {\n                if (event.button !== 0 || event.ctrlKey) return;\n                dragging = {initialValue: this.value,\n                            startingPosition: event.clientX};\n                this.outputs.forEach((e) => e.classList.add('dragging'));\n                event.currentTarget.setPointerCapture(event.pointerId);\n            };\n            const stop = (event) => {\n                dragging = false;\n                this.outputs.forEach((e) => e.classList.remove('dragging'));\n            };\n            const move = (event) => {\n                if (!dragging) return;\n                const pixelsForEntireRange = 200;\n                const scale = pixelsForEntireRange / (this.max - this.min);\n                this.slider.value = dragging.initialValue +\n                    (event.clientX - dragging.startingPosition) / scale;\n                this.updateFromSlider();\n            };\n            const cancel = (event) => {\n                event.preventDefault();\n            };\n\n            el.addEventListener('pointerdown', start);\n            el.addEventListener('pointerup', stop);\n            el.addEventListener('pointercancel', stop);\n            el.addEventListener('pointermove', move);\n            el.addEventListener('dragstart', cancel);\n            el.addEventListener('touchstart', cancel);\n\n            el.classList.add('scrubbable');\n        }\n    }\n\n    updateOutputs() {\n        for (let el of this.outputs) {\n            el.textContent = this.value.toFixed(this.digits);\n            el.classList.toggle('at-min', this.value <= this.min);\n            el.classList.toggle('at-max', this.value >= this.max);\n        }\n    }\n}\n\n\n\n// // Static diagram: noise\n// (function() {\n//     const map = makeNoise(400, 200, 3, 500);\n//     new Renderer2D('render-noise', map, Colormap.gray()).draw();\n// })();\n\n\n// Static diagram: noise drawn as elevation\n// (function() {\n//     const map = makeNoise(300, 200, 2, SEED);\n//     new RendererBoth('render-elevation', map, Colormap.greengray()).draw();\n// })();\n\n\n// Dynamic diagram: Brush\n(function() {\n    let map = new _map2d__WEBPACK_IMPORTED_MODULE_1__[\"default\"](400, 200);\n    let renderer = new _renderboth__WEBPACK_IMPORTED_MODULE_4__[\"default\"]('brush', map, _colormap__WEBPACK_IMPORTED_MODULE_6__.gray());\n    renderer.draw();\n\n    // Add event listener\n    let canvas2d = document.getElementById(\"brush-2d\");\n    let brushSize = 40;\n    canvas2d.addEventListener(\"click\", e => {\n      map.brush(e.offsetX, e.offsetY, brushSize, 0.3);\n      renderer.draw();\n    });\n})();\n\n// Dynamic diagram: Seed and Frequency Variation\n(function() {\n  let map = new _map2d__WEBPACK_IMPORTED_MODULE_1__[\"default\"](400, 200);\n  let renderer = new _renderboth__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\"seed-freq\", map, _colormap__WEBPACK_IMPORTED_MODULE_6__.greengray());\n  \n  let slider_seed = new Slider(\"seed-freq-seed\", redraw);\n  let slider_freq = new Slider(\"seed-freq-freq\", redraw);\n  \n  function redraw() {\n    let seed = slider_seed.value;\n    let freq = slider_freq.value;\n    (0,_noise_utils__WEBPACK_IMPORTED_MODULE_5__.fillNoise)(map, freq, seed);\n    renderer.draw();\n  }\n  redraw();\n})();\n\n// Dynamic diagram: Octave Composition\n(function() {\n  const efreq = 1;\n  let freq_slider = new Slider('octaves-slider', redraw);\n  let elevation = new _map2d__WEBPACK_IMPORTED_MODULE_1__[\"default\"](400, 200);\n  let height = new _map2d__WEBPACK_IMPORTED_MODULE_1__[\"default\"](400, 200);\n  let dx = 0.0, dy = 0.0;\n  \n  let renderer = new _renderboth__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\"octaves\", elevation, _colormap__WEBPACK_IMPORTED_MODULE_6__.greengray());\n\n  function redraw() {\n    let freq = freq_slider.value;\n    let eseed = 11;\n    let espectrum = [1, 1/2*freq, 1/4*freq, 1/8*freq, 1/16*freq];\n    \n    let emixer = mixNoiseWithOffset(elevation, espectrum, efreq, eseed);\n\n    // const exponenent = 5;\n    // reshapeNoiseExponent(height, elevation, exponenent);\n\n    emixer(dx, dy);\n    renderer.draw();\n  }\n  redraw();\n})();\n\n// Dynamic diagram: Everything Combined\n(function() {\n    const efreq = 1, mfreq = 0.3;\n    let freq_slider = new Slider('game-freq', redraw);\n    let water_slider = new Slider('game-waterlevel', redraw);\n    let elev_seed = new Slider('game-elev-seed', redraw);\n    let mois_seed = new Slider('game-mois-seed', redraw);\n\n    let elevation = new _map2d__WEBPACK_IMPORTED_MODULE_1__[\"default\"](150, 150);\n    let moisture = new _map2d__WEBPACK_IMPORTED_MODULE_1__[\"default\"](150, 150);\n    let height = new _map2d__WEBPACK_IMPORTED_MODULE_1__[\"default\"](150, 150);\n    let dx = 0.0, dy = 0.0;\n\n    const exponent = 5;\n    let colors = _colormap__WEBPACK_IMPORTED_MODULE_6__.discretebiomes(elevation, moisture);\n    let renderer = new _renderboth__WEBPACK_IMPORTED_MODULE_4__[\"default\"]('game', height, colors);\n\n\n    function redraw() {\n      let freq = freq_slider.value;\n      let eseed = elev_seed.value, mseed = mois_seed.value;\n      let espectrum = [1, 1/2*freq, 1/4*freq, 1/8*freq, 1/16*freq];\n      let mspectrum = [1, 1/2*freq, 1/3*freq, 1/4*freq, 1/5*freq, 1/4*freq, 1/3*freq, 1/5*freq];\n      \n      let emixer = mixNoiseWithOffset(elevation, espectrum, efreq, eseed);\n      let mmixer = mixNoiseWithOffset(moisture, mspectrum, mfreq, mseed);\n      \n      colors = _colormap__WEBPACK_IMPORTED_MODULE_6__.discretebiomes(elevation, moisture);\n\n      emixer(dx, dy);\n      mmixer(dx, dy);\n\n      (0,_noise_utils__WEBPACK_IMPORTED_MODULE_5__.reshapeNoiseExponent)(height, elevation, exponent);\n      let level = Math.pow(water_slider.value, 3);\n      console.log(water_slider.value);\n      \n      for (let id = 0; id < elevation.size; id++) {\n          if (elevation.data[id] < level) { elevation.data[id] = 0; }\n      }\n    \n      renderer.draw();\n    }\n    redraw();\n  })();\n\n\n// // Static diagram: add frequencies together\n// (function() {\n//     new Renderer2D('render-addition-1', makeNoise(100, 100, 2, SEED), Colormap.gray()).draw();\n//     new Renderer2D('render-addition-2', makeNoise(100, 100, 8, SEED+1), Colormap.gray()).draw();\n//     new Renderer2D('render-addition-3', makeNoise(100, 100, 32, SEED+2), Colormap.gray()).draw();\n//     let map = new Map2D(100, 100);\n//     mixNoise(map, [1, 1/2, 1/4, 1/8, 1/16], 1);\n//     new Renderer2D('render-addition-sum', map, Colormap.gray()).draw();\n// })();\n\n\n// // Create a single shared map\n// let sharedMap = new Map2D(150, 100);\n\n// // Dynamic diagram: show mixing of frequencies\n// (function() {\n//     let slider = new Slider('noise-fbm-mix', redraw);\n//     let renderer = new RendererBoth('render-noise-fbm', sharedMap, Colormap.greengray());\n\n//     function redraw() {\n//         console.log(\"Octaves\");\n//         // Adjust noise mixing directly on the shared map\n//         const spectrum = [1, slider.value / 2, slider.value / 4];\n//         mixNoise(sharedMap, spectrum, 2);\n//         renderer.draw();\n//     }\n\n//     redraw();\n// })();\n\n\n// // Dynamic diagram: show exponent applied to elevation\n// (function() {\n//     let map2 = new Map2D(150, 100);  // Temporary structure for transformation\n//     let slider = new Slider('noise-exponent', redraw);\n//     let renderer = new Renderer3D('render-exponent-3d', map2, Colormap.greengray());\n//     let svgChart = new SvgRemappingChart(\"#chart-exponent\");\n\n//     function redraw() {\n//         console.log(\"Redistribution\");\n//         const exponent = slider.value;\n//         const transform = e => Math.pow(e, exponent);\n\n//         // Directly modify sharedMap instead of creating a new one\n//         reshapeNoiseExponent(map2, sharedMap, exponent);\n//         renderer.draw();\n//         svgChart.setFn(transform);\n//     }\n\n//     redraw();\n// })();\n\n\n\n// // Dynamic diagram: show water level\n// (function() {\n//     const exponent = 3;\n//     let map1 = new Map2D(150, 100);\n//     let map2 = new Map2D(150, 100);\n//     let colors = Colormap.waterlevel(Colormap.greengray());\n//     let slider = new Slider('waterlevel', redraw);\n//     let renderer = new RendererBoth('render-waterlevel', map2, colors);\n//     function redraw() {\n//         let level = Math.pow(slider.value, exponent);\n//         mixNoise(map1, [1, 1/2, 1/4], 2);\n//         reshapeNoiseExponent(map2, map1, exponent);\n//         for (let id = 0; id < map2.size; id++) {\n//             if (map2.data[id] < level) { map2.data[id] = level-(1/255); }\n//         }\n//         colors.setLevel(level*255);\n//         renderer.draw();\n//     }\n//     redraw();\n// })();\n\n\n// // Static diagram: show terrain bands\n// (function() {\n//     const exponent = 5;\n//     let map1 = new Map2D(150, 100);\n//     let map2 = new Map2D(150, 100);\n//     let colors = Colormap.terrainbands();\n//     let renderer = new RendererBoth('render-terrainbands', map2, colors);\n//     mixNoise(map1, [1, 1/4, 1/8, 1/16], 2);\n//     reshapeNoiseExponent(map2, map1, exponent);\n//     renderer.draw();\n// })();\n\n\n// // Static diagram: show E and M noise\n// (function() {\n//     const exponent = 5;\n//     let elevation1 = new Map2D(150, 100);\n//     let elevation2 = new Map2D(150, 100);\n//     let moisture = new Map2D(150, 100);\n//     let rendererE = new Renderer2D('render-both-elevation', elevation2, Colormap.greengray());\n//     let rendererM = new Renderer2D('render-both-moisture', moisture, Colormap.grayblue());\n    \n//     mixNoise(elevation1, [1, 1/4, 1/8, 1/16], 2);\n//     reshapeNoiseExponent(elevation2, elevation1, exponent);\n//     rendererE.draw();\n    \n//     mixNoise(moisture, [1, 1/2, 1/4], 2, 5551212);\n//     rendererM.draw();\n// })();\n\n\n// // Static diagram: show discrete biomes\n// (function() {\n//     const exponent = 5;\n//     let elevation = new Map2D(150, 100);\n//     let moisture = new Map2D(150, 100);\n//     let height = new Map2D(150, 100);\n//     let colors = Colormap.discretebiomes(elevation, moisture);\n//     let renderer = new Renderer3D('render-discretebiomes-3d', height, colors);\n//     mixNoise(elevation, [1, 1/4, 1/8, 1/16], 2);\n//     reshapeNoiseExponent(height, elevation, exponent);\n    \n//     mixNoise(moisture, [1, 1/2, 1/4], 2, 5551212);\n    \n//     renderer.draw();\n// })();\n\n\n// // Dynamic diagram: show island reshaping\n// (function() {\n//     let seed = 1991; // nice default seed\n//     let elevation = new Map2D(300, 200);\n//     let height = new Map2D(300, 200);\n//     let colors = Colormap.waterlevel(Colormap.greengray());\n//     colors.setLevel(127);\n//     let renderer = new RendererBoth('render-island', height, colors);\n//     let shape = new Slider('island-shape', redraw);\n\n//     const distanceFns = {\n//         SquareBump: (nx, ny) => 1 - (1-nx*nx) * (1-ny*ny),\n//         EuclideanSquared: (nx, ny) => Math.min(1, (nx*nx + ny*ny) / Math.sqrt(2)),\n//         Diagonal: (nx, ny) => Math.max(Math.abs(nx), Math.abs(ny)),\n//         Manhattan: (nx, ny) => (Math.abs(nx) + Math.abs(ny)) / 2,\n//         Euclidean: (nx, ny) => Math.hypot(nx, ny) / Math.sqrt(2),\n//         Hyperboloid: (nx, ny) => (Math.hypot(nx, ny, 0.2) - 0.2) / (Math.hypot(1, 1, 0.2) - 0.2),\n//         Blob: (nx, ny) => Math.hypot(nx, ny-0.05)**2 / Math.sqrt(2) * 2.7 / (3 - Math.sin(5 * Math.atan2(ny-0.05, nx))),\n//     };\n\n//     const reseedButton = document.querySelector(\"#island-reseed\");\n//     reseedButton.addEventListener('click', () => { seed = Math.random()*10000|0; generate(); });\n    \n//     const distanceSelector = document.querySelector(\"#island-distance-fn\");\n//     distanceSelector.innerHTML = Object.keys(distanceFns).map(name => `<option value=\"${name}\">${name}</option>`).join(\"\");\n//     distanceSelector.addEventListener('change', redraw);\n    \n//     function lerp(a, b, t) { return a * (1-t) + b * t; }\n//     function reshape(e, d) { return lerp(e, 1-d, shape.value); }\n\n//     function redraw() {\n//         let distanceFn = distanceFns[distanceSelector.value ?? 'SquareBump'];\n//         for (let y = 0; y < elevation.h; y++) {\n//             for (let x = 0; x < elevation.w; x++) {\n//                 // Transform the height to make islands\n//                 let nx = 2*(x/elevation.w) - 1;\n//                 let ny = 2*(y/elevation.h) - 1;\n//                 let e = elevation.get(x, y);\n//                 let d = distanceFn(nx, ny);\n//                 if (d < 0) d = 0;\n//                 if (d > 1) d = 1;\n//                 e = reshape(e, d);\n//                 height.set(x, y, e);\n//             }\n//         }\n//         renderer.draw();\n//     }\n    \n//     function generate() {\n//         mixNoise(elevation, [1, 1/2, 1/4, 1/8, 1/16], 2, seed);\n//         redraw();\n//     }\n\n//     generate();\n    \n//     // Also draw the SVG linear conversion diagram\n//     function updateSvgLinearConversion() {\n//         let g = document.querySelector(\"#diagram-linear-conversion g\");\n//         let html = ``;\n//         for (let {x, f, label} of\n//              [{x: 25, f: level => level/2, label: \"Force land\"},\n//               {x: 150, f: level => level/2+25, label: \"\"},\n//               {x: 275, f: level => level/2+50, label: \"Force water\"}]) {\n//             html += `<g transform=\"translate(${x}, 0)\">`;\n//             for (let level = 5; level <= 95; level += 10) {\n//                 html += `<path d=\"M 0 ${level} C 50 ${level} 50 ${f(level)} 100 ${f(level)}\" />`;\n//             }\n//             html += `<text stroke=\"none\" fill=\"black\" font-size=\"10\" x=\"50\" y=\"110\" text-anchor=\"middle\">${label}</text>`;\n//             html += `</g>`;\n//         }\n//         g.innerHTML = html;\n//     }\n    \n//     updateSvgLinearConversion();\n// })();\n\n\n// // Dynamic diagram: show terraces\n// (function() {\n//     const exponent = 3;\n//     let elevation = new Map2D(300, 150);\n//     let height = new Map2D(300, 150);\n//     let terraced = new Map2D(300, 150);\n//     let colors = Colormap.waterlevel(Colormap.terrainbands());\n//     colors.setLevel(20);\n//     let renderer = new Renderer3D('render-terraces-3d', terraced, colors);\n//     let slider_numlevels = new Slider('terraces-numlevels', redraw); slider_numlevels.digits = 0; slider_numlevels.updateOutputs();\n//     let svgChart = new SvgRemappingChart(\"#chart-terraces\");\n\n//     mixNoise(elevation, [1, 1/4, 1/8, 1/16], 1, 5551215);\n//     reshapeNoiseExponent(height, elevation, exponent);\n\n//     function redraw() {\n//         const numlevels = slider_numlevels.value;\n//         const transform = e => Math.round(e * numlevels) / numlevels;\n//         for (let y = 0; y < height.h; y++) {\n//             for (let x = 0; x < height.w; x++) {\n//                 terraced.set(x, y, transform(height.get(x, y)));\n//             }\n//         }\n//         renderer.draw();\n//         svgChart.setFn(transform);\n//     }\n//     redraw();\n// })();\n\n\n// // Dynamic diagram: blue noise to trees\n// (function() {\n//     let bluenoise = new Map2D(150, 150);\n//     let trees = new Map2D(150, 150);\n//     let renderer_in = new Renderer2D('render-trees-2d-in', bluenoise, Colormap.grayblue());\n//     let renderer_out = new Renderer2D('render-trees-2d-out', trees, Colormap.gray());\n//     let slider_radius = new Slider('trees-radius', redraw); slider_radius.digits = 0; slider_radius.updateOutputs();\n//     mixNoise(bluenoise, [1/2, 0, 0, 0, 0, 0, 0, 0, 1], 1/6, 5551215);\n//     renderer_in.draw();\n\n//     function redraw() {\n//         let R = slider_radius.value;\n//         for (let yc = 0; yc < bluenoise.h; yc++) {\n//             for (let xc = 0; xc < bluenoise.w; xc++) {\n//                 let max = 0;\n//                 for (let dy = -R; dy <= R; dy++) {\n//                     for (let dx = -R; dx <= R; dx++) {\n//                         let xn = dx + xc, yn = dy + yc;\n//                         // optionally check that (dx*dx + dy*dy <= R * (R + 1))\n//                         if (0 <= yn && yn < bluenoise.h && 0 <= xn && xn < bluenoise.w) {\n//                             let e = bluenoise.get(xn, yn);\n//                             if (e > max) { max = e; }\n//                         }\n//                     }\n//                 }\n//                 trees.set(xc, yc, bluenoise.get(xc, yc) === max? 0 : 255);\n//             }\n//         }\n//         renderer_out.draw();\n//     }\n//     redraw();\n// })();\n\n\n// // Static diagram: variable density trees\n// (function() {\n//     const exponent = 5;\n//     let elevation = new Map2D(300, 150);\n//     let height = new Map2D(300, 150);\n//     let moisture = new Map2D(300, 150);\n//     let bluenoise = new Map2D(300, 150);\n//     let trees = new Map2D(300, 150);\n//     let renderer_terrain = new Renderer2D('render-trees-2d-terrain', elevation,\n//                                          Colormap.discretebiomes(elevation, moisture));\n//     let renderer_trees = new Renderer2D('render-trees-2d-variable-density-trees',\n//                                         trees, Colormap.gray());\n    \n//     mixNoise(bluenoise, [1], 40, 5551215);\n//     mixNoise(elevation, [1, 1/4, 1/8, 1/16], 2);\n//     reshapeNoiseExponent(height, elevation, exponent);\n//     mixNoise(moisture, [1, 1/2, 1/4], 2, 5551212);\n\n//     for (let yc = 0; yc < bluenoise.h; yc++) {\n//         for (let xc = 0; xc < bluenoise.w; xc++) {\n//             let max = 0;\n//             let R = Math.min(10, Math.round(0.1 + 0.4 / Math.max(0.1, moisture.get(xc, yc) - 0.5*elevation.get(xc, yc))));\n//             if (elevation.get(xc, yc) < 0.32) { max = Infinity; }\n//             for (let yn = yc - R; yn <= yc + R; yn++) {\n//                 for (let xn = xc - R; xn <= xc + R; xn++) {\n//                     let e = bluenoise.get(xn, yn);\n//                     if (e > max) { max = e; }\n//                 }\n//             }\n//             trees.set(xc, yc, bluenoise.get(xc, yc) == max ? 0 : 255);\n//         }\n//     }\n    \n//     renderer_terrain.draw();\n//     renderer_trees.draw();\n\n//     // Combine the two images into one; since the images are cached\n//     // I'm using those instead of re-rendering the canvases here. I\n//     // had to mark them with an id in the html. However we have to\n//     // wait for both images to load.\n//     let image1 = document.getElementById(renderer_terrain.elementId);\n//     let image2 = document.getElementById(renderer_trees.elementId);\n//     function buildCompositeImage() {\n//         if (!image1.complete || !image2.complete) {\n//             setTimeout(buildCompositeImage, 100);\n//             return;\n//         }\n//         let composite = document.getElementById('render-trees-2d-composite');\n//         let ctx = composite.getContext('2d');\n//         ctx.drawImage(image1, 0, 0);\n//         ctx.globalCompositeOperation = 'multiply';\n//         ctx.drawImage(image2, 0, 0);\n//     }\n//     buildCompositeImage();\n// })();\n\n\n// // Static diagram: show smooth biomes\n// (function() {\n//     const exponent = 5;\n//     let elevation = new Map2D(150, 100);\n//     let moisture = new Map2D(150, 100);\n//     let height = new Map2D(150, 100);\n//     let colors = Colormap.smoothbiomes(elevation, moisture);\n//     let renderer = new Renderer3D('render-smoothbiomes-3d', height, colors);\n//     mixNoise(elevation, [1, 1/4, 1/8, 1/16], 2);\n//     reshapeNoiseExponent(height, elevation, exponent);\n    \n//     mixNoise(moisture, [1, 1/2, 1/4], 2, 5551212);\n    \n//     renderer.draw();\n// })();\n\n\n// // Static diagram: show how E+M become a biome. X axis is M, Y axis is E.\n// (function() {\n//     let elevation = new Map2D(100, 100);\n//     let moisture = new Map2D(100, 100);\n//     let colors1 = Colormap.smoothbiomes(elevation, moisture);\n//     let colors2 = Colormap.discretebiomes(elevation, moisture);\n//     let renderer1 = new Renderer2D('biome-lookup-smooth', elevation, colors1);\n//     let renderer2 = new Renderer2D('biome-lookup-discrete', elevation, colors2);\n\n//     for (let y = 0; y < elevation.h; y++) {\n//         for (let x = 0; x < elevation.w; x++) {\n//             // These undo the reshaping in the color function :-/\n//             elevation.set(x, y, (1.35 - y/elevation.h) / 1.4);\n//             moisture.set(x, y, (1.0 + x/elevation.w) / 3.0);\n//         }\n//     }\n    \n//     renderer1.draw();\n//     renderer2.draw();\n// })();\n\n\n// // Dynamic diagram: show temperature set from both latitude and elevation\n// (function() {\n//     // NOTE: due to the stupid way I set up the colormaps, the\n//     // land/water transition happens at some weird number\n//     const sea_level = 0.347;\n//     const exponent = 5;\n    \n//     let elevation = new Map2D(300, 150);\n//     let moisture = new Map2D(300, 150);\n//     let height = new Map2D(elevation.w, elevation.h);\n//     let invtemperature = new Map2D(elevation.w, elevation.h);\n//     let colors = Colormap.smoothbiomes(invtemperature, moisture);\n//     let renderer = new Renderer2D('render-latitude-2d', height, colors);\n//     let slider_equator = new Slider('latitude-equator', redraw);\n//     let slider_poles = new Slider('latitude-poles', redraw);\n\n//     mixNoise(elevation, [1, 1/2, 1/3, 1/4, 1/5], 3);\n//     // lower elevation to make more oceans and less land - tweaking here :(\n//     for (let y = 0; y < elevation.h; y++) {\n//         for (let x = 0; x < elevation.w; x++) {\n//             elevation.set(x, y, 1.7 * elevation.get(x, y) - 0.5);\n//         }\n//     }\n//     reshapeNoiseExponent(height, elevation, exponent);\n            \n//     mixNoise(moisture, [1, 1/2, 1/3, 1/4, 1/5], 2, 5551212);\n    \n//     function redraw() {\n//         const a = slider_equator.value, b = slider_poles.value;\n//         for (let y = 0; y < elevation.h; y++) {\n//             for (let x = 0; x < elevation.w; x++) {\n//                 let e = elevation.get(x, y);\n//                 let e0 = e - sea_level;\n//                 if (e0 >= 0) {\n//                     // lots of tweaking needed here :(\n//                     e0 = 10*e0*e0 + b + (a-b) * Math.sin(Math.PI * (y / elevation.h));\n//                     if (e0 < 0) { e0 = 0; }\n//                 }\n//                 invtemperature.set(x, y, sea_level + e0);\n//             }\n//         }\n//         renderer.draw();\n//     }\n\n//     redraw();\n// })();\n\n\n// // Static diagram: demo at top\n// (function() {\n//     const exponent = 5;\n//     let elevation = new Map2D(300, 200);\n//     let moisture = new Map2D(300, 200);\n//     let height = new Map2D(300, 200);\n//     let colors = Colormap.smoothbiomes(elevation, moisture);\n//     let renderer = new Renderer3D('topdemo-3d', height, colors);\n//     mixNoise(elevation, [1, 1/2, 1/4, 1/8, 1/16], 2);\n//     reshapeNoiseExponent(height, elevation, exponent);\n    \n//     mixNoise(moisture, [1, 1/2, 1/3, 1/4, 1/5], 2, 5551212);\n    \n//     renderer.draw();\n// })();\n\n\n// // Dynamic diagram: demo at bottom\n// (function() {\n//     let elevation = new Map2D(300, 200);\n//     let moisture = new Map2D(300, 200);\n//     let height = new Map2D(300, 200);\n//     let colors = Colormap.smoothbiomes(elevation, moisture);\n//     let renderer = new Renderer3D('finaldemo-3d', height, colors);\n\n//     // Make lots of sliders\n//     let s = {};\n//     ['e1', 'e2', 'e3', 'e4', 'e5', 'e6',\n//      'm1', 'm2', 'm3', 'm4', 'm5', 'm6',\n//      'exponent',\n//     ].forEach(function (name) {\n//         s[name] = new Slider('final-' + name, redraw);\n//         s[name].updateOutputs();\n//     });\n    \n//     function redraw() {\n//         mixNoise(elevation, [s.e1.value, s.e2.value, s.e3.value, s.e4.value, s.e5.value, s.e6.value], 2);\n//         reshapeNoiseExponent(height, elevation, s.exponent.value);\n//         mixNoise(moisture, [s.m1.value, s.m2.value, s.m3.value, s.m4.value, s.m5.value, s.m6.value], 2, 5551212);\n//         renderer.draw();\n//     }\n//     redraw();\n// })();\n\n\n// // Dynamic diagram: show ridged noise, with amplitudes depending on the\n// // elevation calculated from lower frequencies\n// (function() {\n//     const exponent = 3;\n//     let noise = SimplexNoise3D(SEED);\n//     let elevation = new Map2D(300, 150);\n//     const aspect = elevation.w / elevation.h;\n//     let moisture = new Map2D(150, 150);\n//     mixNoise(moisture, [1, 1/2, 1/3, 1/4, 1/5, 1/6], 1, 5551216);\n//     let colors = Colormap.smoothbiomes(elevation, moisture);\n//     let renderer3d = new Renderer3D('render-ridged-3d', elevation, colors);\n//     let slider_numlevels = new Slider('ridged-numlevels', redraw); slider_numlevels.digits = 0; slider_numlevels.updateOutputs();\n//     let svgChart = new SvgRemappingChart(\"#chart-ridged\", {step: 0.5});\n//     svgChart.setFn(e => 2 * (0.5 - Math.abs(0.5-e)));\n    \n//     function redraw() {\n//         const {h, w} = elevation;\n//         let numlevels = slider_numlevels.value;\n//         for (let y = 0; y < h; y++) {\n//             for (let x = 0; x < elevation.w; x++) {\n//                 let z = 0, scale = 0, nx = x/w - 0.5, ny = y/h - 0.5;\n//                 for (let octave = 0, frequency = 1; octave < numlevels; octave++, frequency *= 2) {\n//                     let amplitude = 1/frequency;\n//                     if (octave > 0) amplitude *= z;\n//                     scale += amplitude;\n//                     z += amplitude * (1 - Math.abs(noise(nx * aspect * frequency, ny * frequency, octave)));\n//                 }\n//                 elevation.set(x, y, 0.2 + Math.pow(z/scale, exponent));\n//             }\n//         }\n//         renderer3d.draw();\n//     }\n//     redraw();\n// })();\n\n\n/** This version takes dx, dy parameters for scrolling x, y */\nfunction mixNoiseWithOffset(output, spectrum, frequency, seed) {\n    let aspect = output.w / output.h;\n    \n    let scale = 0.0;\n    spectrum.forEach(function(amplitude) { scale += amplitude; });\n    \n    let noise = spectrum.map(function(_, octave) {\n        return (0,_noise_utils__WEBPACK_IMPORTED_MODULE_5__.SimplexNoise2D)(seed + octave);\n    });\n\n    return function(dx, dy) {\n        for (let y = 0; y < output.h; y++) {\n            for (let x = 0; x < output.w; x++) {\n                let nx = dx + x/output.w - 0.5, ny = dy + y/output.h - 0.5;\n                let z = 0.0;\n                for (let octave = 0, exponent = 1; octave < spectrum.length; octave++, exponent *= 2) {\n                    z += spectrum[octave] * ((noise[octave](nx * frequency * aspect * exponent, ny * frequency * exponent))/2 + 0.5);\n                }\n                output.set(x, y, z/scale);\n            }\n        }\n    };\n}\n\n\n// // Static diagram: wraparound maps\n// (function() {\n//     const TAU = 2 * Math.PI;\n//     const seed = 21; // hand chosen to produce maps with good features using simplex-noise@3.0\n//     const spectrum = [1, 1, 1/2, 1/4]; // limit detail to make the big picture more obvious\n//     let scale = spectrum.reduce((x, y) => x + y, 0) * 1.2;\n//     let eNoise3 = spectrum.map((_, octave) => SimplexNoise3D(seed + octave));\n//     let eNoise4 = spectrum.map((_, octave) => SimplexNoise4D(seed + octave));\n//     let mNoise3 = spectrum.map((_, octave) => SimplexNoise3D(seed + octave + 100));\n//     let mNoise4 = spectrum.map((_, octave) => SimplexNoise4D(seed + octave + 100));\n\n//     // Higher dimensional noise tends to have a narrower range, so I try to compensate by increasing\n//     // the range here. See https://digitalfreepen.com/2017/06/20/range-perlin-noise.html\n//     const compensate3DScale = Math.sqrt(3)/Math.sqrt(2);\n//     const compensate4DScale = Math.sqrt(4)/Math.sqrt(2);\n    \n//     function cylindernoise(noise, nx, ny) {\n//         let z = 0.0;\n//         let angle = TAU * nx;\n//         let cosAngle = Math.cos(angle),\n//             sinAngle = Math.sin(angle);\n//         for (let octave = 0, exponent = 1; octave < spectrum.length; octave++, exponent *= 2) {\n//             let n = compensate3DScale * noise[octave](cosAngle/TAU * exponent, sinAngle/TAU * exponent, ny * exponent);\n//             z += spectrum[octave] * (n/2 + 0.5);\n//         }\n//         return z / scale;\n//     }\n    \n//     function torusnoise(noise, nx, ny) {\n//         let z = 0.0;\n//         let angle1 = TAU * nx,\n//             angle2 = TAU * ny;\n//         let cosAngle1 = Math.cos(angle1), sinAngle1 = Math.sin(angle1),\n//             cosAngle2 = Math.cos(angle2), sinAngle2 = Math.sin(angle2);\n//         for (let octave = 0, exponent = 1; octave < spectrum.length; octave++, exponent *= 2) {\n//             let n = compensate4DScale * noise[octave](cosAngle1/TAU * exponent, sinAngle1/TAU * exponent,\n//                                           cosAngle2/TAU * exponent, sinAngle2/TAU * exponent);\n//             z += spectrum[octave] * (n/2 + 0.5);\n//         }\n//         return z / scale;\n//     }\n\n//     let moisture = new Map2D(300, 300);\n//     let elevation = new Map2D(300, 300);\n//     function redraw() {\n//         for (let config of [\n//             {id: 'render-wraparound-ew', f: cylindernoise, eNoise: eNoise3, mNoise: mNoise3},\n//             {id: 'render-wraparound-nsew', f: torusnoise, eNoise: eNoise4, mNoise: mNoise4}\n//         ]) {\n//             let renderer = new Renderer2D(config.id, elevation,\n//                                           Colormap.discretebiomes(elevation, moisture));\n//             for (let y = 0; y < elevation.h; y++) {\n//                 for (let x = 0; x < elevation.w; x++) {\n//                     let nx = (2 * x + elevation.w/2) % elevation.w / elevation.w, ny = (2 * y + elevation.h/2) % elevation.h / elevation.h;\n//                     let e = config.f(config.eNoise, nx, ny);\n//                     let m = config.f(config.mNoise, nx, ny);\n//                     if ((2 * x) % elevation.w === elevation.w / 2 || (2 * y) % elevation.h === elevation.h / 2) { e = 1; m = 1; }\n//                     elevation.set(x, y, e);\n//                     moisture.set(x, y, m);\n//                 }\n//             }\n//             renderer.draw();\n//         }\n//     }\n//     redraw();\n// })();\n\n\n// // Dynamic diagram: allow scrolling of 2D map\n// (function() {\n//     const eseed = 12345, mseed = 123456;\n//     const efreq = 1, mfreq = 0.3;\n//     const espectrum = [1, 1/2, 1/4, 1/8, 1/16], mspectrum = [1, 1/2, 1/3, 1/4, 1/5, 1/4, 1/3, 1/5];\n//     const magnify = 7;\n\n//     // Draw the minimap\n//     let minielevation = new Map2D(150, 150);\n//     let minimoisture = new Map2D(150, 150);\n//     mixNoise(minielevation, espectrum, magnify * efreq, eseed);\n//     mixNoise(minimoisture, mspectrum, magnify * mfreq, mseed);\n//     let control = new Renderer2D('scrolling', minielevation, Colormap.discretebiomes(minielevation, minimoisture));\n//     control.draw(); // can't use the cached img for events (leaky abstraction, sigh)\n    \n    \n//     // Draw the main map, reusing as much as possible between redraws\n//     let elevation = new Map2D(150, 150);\n//     let emixer = mixNoiseWithOffset(elevation, espectrum, efreq, eseed);\n//     let moisture = new Map2D(150, 150);\n//     let mmixer = mixNoiseWithOffset(moisture, mspectrum, mfreq, mseed);\n//     let height = new Map2D(150, 150);\n//     const exponent = 5;\n//     let colors = Colormap.discretebiomes(elevation, moisture);\n//     let renderer = new Renderer3D('render-scrolling-3d', height, colors);\n//     let dx = 0.0, dy = 0.0;\n    \n//     function redraw() {\n//         emixer(dx, dy);\n//         mmixer(dx, dy);\n//         reshapeNoiseExponent(height, elevation, exponent);\n//         renderer.draw();\n//     }\n//     redraw();\n\n//     // NOTE: the img src will have a timestamp appended on it by my build system\n//     let img = document.querySelector('img[src^=\"images/scrolling.png\"]') ?? document.querySelector('canvas#scrolling');\n//     img.style.touchAction = \"none\";\n//     img.addEventListener('pointermove', function(e) {\n//         dx = (e.offsetX / img.clientWidth - 0.5) * magnify;\n//         dy = (e.offsetY / img.clientHeight - 0.5) * magnify;\n//         requestAnimationFrame(redraw);\n//     });\n// })();\n\n\n//# sourceURL=webpack:///./src/simplemapgen.js?");

/***/ }),

/***/ "./src/visualize-reshaper.ts":
/*!***********************************!*\
  !*** ./src/visualize-reshaper.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SvgRemappingChart)\n/* harmony export */ });\n/*\n * From https://www.redblobgames.com/maps/terrain-from-noise/\n * Copyright 2022 Red Blob Games <redblobgames@gmail.com>\n * License: Apache-2.0 <http://www.apache.org/licenses/LICENSE-2.0.html>\n */\n/** Show before/after values of elevation or moisture */\nclass SvgRemappingChart {\n    constructor(selector, options = {}) {\n        var _a, _b, _c;\n        this.step = (_a = options.step) !== null && _a !== void 0 ? _a : 0.01;\n        this.digits = (_b = options.digits) !== null && _b !== void 0 ? _b : 3;\n        this.svg = typeof selector === 'string' ? document.querySelector(selector) : selector;\n        if (!this.svg) {\n            throw new Error(`SVG element not found for selector: ${selector}`);\n        }\n        this.svg.setAttribute('viewBox', \"-0.11 -0.01 1.12 1.12\");\n        this.svg.innerHTML += `\n        ${(_c = options.prefixSvg) !== null && _c !== void 0 ? _c : \"\"}\n        <path fill=\"none\"  stroke=\"#ccc\" stroke-width=\"0.007\" d=\"M 0,0 l 0,1 l 1,0 M 0,1 l 1,-1\"/>\n        <g fill=\"#999\" font-size=\"0.1\" text-anchor=\"middle\" transform=\"translate(0,1)\">\n          <text x=\"0.03\" y=\"0.1\">0</text>\n          <text x=\"0.97\" y=\"0.1\">1</text>\n          <text x=\"0.5\" y=\"0.1\">Before</text>\n          <g transform=\"rotate(-90) translate(0,-0.02)\">\n            <text x=\"0.03\" y=\"0\">0</text>\n            <text x=\"0.97\" y=\"0\">1</text>\n            <text x=\"0.5\" y=\"0\">After</text>\n          </g>\n        </g>\n        <path fill=\"none\" stroke=\"#a44\" stroke-width=\"0.02\" stroke-linecap=\"round\" transform=\"translate(0,1), scale(1,-1)\" d=\"\"/>`;\n        const pathElement = this.svg.querySelector(\"path[d='']\");\n        if (!pathElement) {\n            throw new Error(\"Path element not found\");\n        }\n        this.path = pathElement;\n    }\n    setFn(remapFn) {\n        const { step, digits } = this;\n        let points = [];\n        for (let e = 0; e <= 1; e += step) {\n            points.push(`${e.toFixed(digits)},${remapFn(e).toFixed(digits)}`);\n        }\n        let d = \"M \" + points.join(\" L \");\n        this.path.setAttribute('d', d);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/visualize-reshaper.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;